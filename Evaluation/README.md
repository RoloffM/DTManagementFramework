

Background for Table 1: "NUMBER OF HIGH-LEVEL OPERATIONS REQUIRED TO REALIZE THE SCENARIOS 1.1 - 2.4 IN THE THREE SETTINGS OF THE CASE STUDY"


| Scenario              | Baseline Scratch                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Baseline DT Platform                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | DTManager                                                                                                                                                                                                                               |
|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *Scenario 1.1* | Start the simulation engine + define the simulation object class or simulation microservice + Instantiate the simulation object or microservice + set up endpoint interface + Define the protocol for exchanging data with the simulation engine + Define the class for the DT object or the container to run microservices + instantiate DT object containing the experimental DT state or run the microservice infrastructure + bind the experimental DT object or the microservices to the messages coming from the simulation (8 Operations)                                                                | Start the simulation engine + define the simulation object class + Instantiate the simulation object + set up endpoint interface + instantiate DT object containing the experimental DT state + bind the experimental DT object to the messages coming from the simulation (7 Operations)                                                                                                                                                                                                                                                                                                                       | Start the simulation engine + Create an experimental DT + assign endpoint type for simulation + provide DT configuration (4 Operations)                                                                                                 |
| *Scenario 1.2* | Define the protocol/messaging to run an operation on the PT + execute operation on the PT + define the protocol/messaging to run an operation in the simulation engine + execute operation on the simulation (4 Operations)                                                                                                                                                                                                                                                                                                                                                                                     | Execute operation on the PT + define the protocol/messaging to run an operation in the simulation engine + execute operation on the simulation (3 Operations)                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Execute operations on both with \textit{DTManager.executeOperationOn(...)* (1 Operation)                                                                                                                                                |
| *Scenario 1.3* | Create new DT instance or microservice + set up the endpoint to the simulation unit + get the current state of the existing DT per attribute + set current state of the new DT per attribute ($2 + 2 \times N_{attributes}$ operations)                                                                                                                                                                                                                                                                                                                                                                      | Create new DT instance + set up the endpoint to the simulation unit + get the current state of the existing DT per attribute + set current state of the new DT per attribute ($2 + 2\times N_{attributes}$ operations)                                                                                                                                                                                                                                                                                                                                                                                          | Clone existing experimental DT + copy state of the actual DT to the new experimental DT (2 operations)                                                                                                                                  |
| *Scenario 1.4* | Implement the timer\slash counter method + generate the blocking method in the code or update the step size of the simulation and create a new calling method with the timestep as argument + get attribute value of the experimental DT (3 operations)                                                                                                                                                                                                                                                                                                                                                         | Implement the timer\slash counter method + generate the blocking method in the code or update the step size of the simulation and create a new calling method with the timestep as argument + get attribute value of the experimental DT (3 operations)                                                                                                                                                                                                                                                                                                                                                         | Get the attribute value of the experimental DT with DTManager.getAttributeValueAt(..., clock = getNow() + 5) (1 operation)                                                                                                              |
| *Scenario 1.5* | Implement the timer\slash counter method + generate the blocking method in the code + get the current state of the actual DT per attribute + set current state of the experimental DT per attribute ($2 + 2\times N_{attributes}$ operations)                                                                                                                                                                                                                                                                                                                                                                   | Implement the timer\slash counter method + generate the blocking method in the code + get the current state of the actual DT per attribute + set current state of the experimental DT per attribute ($2 + 2\times N_{attributes}$ operations)                                                                                                                                                                                                                                                                                                                                                                   | Copy the DT state of the actual DT to the experimental DT in 5 timesteps in the future with DTManager.copy(from, to, clock = getNow() + 5) (1 operation)                                                                                |
| *Scenario 1.6* | Rerun the simulation engine + Redefine the simulation object class or simulation microservice + instantiate the simulation object or microservice + update the endpoint to the simulation unit + update the protocol to the endpoint of the simulation unit + redefine the object class of the experimental DT or container for microservices + instantiate the object of the experimental DT or run the microservice infrastructure + update the binding of the experimental DT to the simulation endpoint + update the calls of the execute operation method to the new name ($8 + N_{OpCalls}$ operations) | Rerun the simulation engine + Redefine the simulation object class or simulation microservice + instantiate the simulation object or microservice + update the endpoint to the simulation unit + update the protocol to the endpoint of the simulation unit + redefine the object class of the experimental DT or container for microservices + instantiate the object of the experimental DT or run the microservice infrastructure + update the binding of the experimental DT to the simulation endpoint + update the calls of the execute operation method to the new name ($8 + N_{OpCalls}$ operations) | Rerun the simulation engine + Replace the model file in the simulation engine + update the schema file + update the calls of the executeOperation method to the new name ($3 + N_{OpCalls}$ operations)                               |
| *Scenario 1.7* | Rerun the simulation engine + Redefine the simulation object class or simulation microservice + instantiate the simulation object or microservice + update the endpoint to the simulation unit + update the protocol to the endpoint of the simulation unit + redefine the object class of the experimental DT or container for microservices + instantiate the object of the experimental DT or run the microservice infrastructure + update the binding of the experimental DT to the simulation endpoint + update the calls of the execute operation method to the new name ($8 + N_{OpCalls}$ operations) | Rerun the simulation engine + Redefine the simulation object class or simulation microservice + instantiate the simulation object or microservice + update the endpoint to the simulation unit + update the protocol to the endpoint of the simulation unit + redefine the object class of the experimental DT or container for microservices + instantiate the object of the experimental DT or run the microservice infrastructure + update the binding of the experimental DT to the simulation endpoint + update the calls of the execute operation method to the new name ($8 + N_{OpCalls}$ operations) | Rerun the simulation engine + Replace the model file in the simulation engine + update the schema file + create a new experimental DT + update the calls of the executeOperation method to the new name ($4 + N_{OpCalls}$ operations |
| *Scenario 2.1* | Create new DT class or microservice container + design DT class attributes and operations or microservices + set up the endpoint to the physical device + define the protocol to get the messages from the physical device + instantiate DT object or run the microservice infrastructure + bind the DT object or microservices to the messages and attributes + change business logic (8 operations)                                                                                                                                                                                                           | Provide new schema file + create the actual DT + set up/bind the endpoint configuration + change business logic (4 operations)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Provide new schema file + provide new config file  + create actual DT + set up/bind the endpoint configuration + change business logic  (5 operations)                                                                                  |
| *Scenario 2.2* | Start the simulation engine + define the simulation object classes or microservices (2) + instantiate the simulation objects or microservices (2) + set up the endpoint for each experimental DT (2) +  + define the classes for the experimental DTs or containers for microservices (2) + instantiate DT objects for experimental DTs or run the microservice infrastructure (2) + define the messaging protocol for each experimental DT (2) + bind the experimental DTs to the simulation endpoints (2) + change business logic (16 operations)                                                             | Start the simulation engine + define the simulation object classes (2) + instantiate the simulation objects (2) + set up the endpoint for each experimental DT (2) + create DT objects for the experimental DTs (2) + bind the experimental DTs to the simulation endpoints (2) + change business logic (12 operations)                                                                                                                                                                                                                                                                                         | Start the simulation engine + Provide new schema file + provide new config files (2) + create experimental DTs (2) + change business logic  (7 operations)                                                                              |
| *Scenario 2.3* | Design the timing mapping mechanism + design the timing mapping function + design the inverse function + integrate the mapping function to the DT + implement the timer\slash counter method + generate the blocking method in the code + call the execute operation function at a shifted time (7 functions)                                                                                                                                                                                                                                                                                                   | Design the timing mapping mechanism + design the timing mapping function + design the inverse function + integrate the mapping function to the DT + implement the timer\slash counter method + generate the blocking method in the code + call the execute operation function at a shifted time (7 functions)                                                                                                                                                                                                                                                                                                   | Convert clock time from integer to timestamp integer by multiplying by 1000 (ms) or applying the inverse function + call executeOperationAt with the mapped argument (2 operations)                                                     |
| *Scenario 2.4* | Define the attributes to be monitored + define the DTs to be monitored + define the tolerance + read the attribute values on each twin to be monitored ($N_{attributes}\times N_{twins}$) + compare for deviation ($4 + N_{attributes}\times N_{twins}$ operations)                                                                                                                                                                                                                                                                                                                                             | Define the attributes to be monitored + define the DTs to be monitored + define the tolerance + read the attribute values on each twin to be monitored ($N_{attributes}\times N_{twins}$) + compare for deviation ($4 + N_{attributes}\times N_{twins}$ operations)                                                                                                                                                                                                                                                                                                                                             | Define the attribute to be monitored + define the DTs to be monitored + define the tolerance + execute get attribute values operation + compare for deviation (5 operations) |
